## 1. 배경

포인트 시스템은 사용자에게 혜택을 제공하거나 결제 수단으로 사용되는 중요한 기능이다. 
특히, 포인트 충전(적립)과 사용(차감)은 정확한 정산이 요구되며, 동시 요청 시 데이터 정합성 보장이 매우 중요하다.

대규모 사용자 환경에서는 충전과 사용 요청이 거의 동시에 발생할 수 있기 때문에 동시성 이슈가 발생할 수 있으며, 적절한 제어가 없다면 포인트 중복 사용, 음수 포인트, 충전 누락
등의 문제가 나타날 수 있다.

## 2. 문제 (AS-IS)

다음과 같은 조건의 포인트 시스템을 구성하고 있었다
- 유저는 언제든지 포인트를 충전하거나 사용할 수 있음
- 포인트 잔액은 Point 테이블에서 관리
- 포인트 적립/차감 이력은 PointHistory에 저장

실제 운영 중 아래와 같은 문제가 발생했다.
- 동시에 사용 요청이 들어오면서 포인트가 음수로 내려감
- 충전과 사용이 동시에 발생할 경우, 최종 포인트 잔액이 불일치
- 포인트 사용 중 두 요청이 같은 시점에 처리되어 중복 차감 발생

## 3. 해결 방법 (TO-BE)

1. 비관적 락 적용
- Point 엔티티 조회 시 SELECT ... FOR UPDATE를 통해 해당 유저의 포인트 row를 락으로 제어
- 트랜잭션이 끝날 때까지 다른 트랜잭션은 해당 유저의 포인트 정보를 갱신할 수 없도록 차단

2. 트랜잭션 일관성 보장
- 충전 및 사용 처리를 하나의 트랜잭션으로 처리
- 포인트 변경 전후 상태와 PointHistory 기록을 함께 처리하여 원자성 보장

3. 음수 방지 로직
- 포인트 차감 시 현재 포인트가 충분한지 먼저 확인하고, 부족하면 `INSUFFICIENT_POINTS` 예외를 발생시킴 

## 4. 한계점

- 비관적 락 특성상 다수의 요청이 동시에 같은 유저의 포인트에 접근 시, 처리 지연 또는 대기 발생
- 특정 유저에 대한 연속된 요청이 몰릴 경우, 락 획득 대기 시간이 길어질 수 있음
-배타적 락은 단일 DB 인스턴스 내에서만 유효하며, 다중 DB 또는 분산 시스템에서는 Redis-based 분산 락이 필요할 수 있음

## 5. 결론

- 유저 포인트 시스템은 재무적인 민감 요소와 직결되므로 높은 정합성이 요구된다. 
  배타적 락을 통해 동일 유저의 포인트 정보를 동시에 수정하는 것을 방지하고, 포인트 충전 및 사용 간의 순서를 보장함으로써 중복 사용, 음수 문제 등을 해결할 수 있었다.
- 배타적 락은 단일 노드 환경에서 효과적으로 동시성 문제를 제어할 수 있으나, 대규모 트래픽 또는 분산 환경에서는 락 확장을 위한 Redis 분산 락, 큐 기반 처리, 비동기 보정
로직과 같은 추가 전략도 고려해 볼 수 있다.

